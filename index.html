<!DOCTYPE html>
<html>
<head>
	<title>Tower Stacking Game</title>
	<style>
      body { margin: 0; , overscroll-behavior-y: none;}
      canvas { display: white; }
      #ui-text {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 18px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
      }
    </style>
</head>
<body>
  
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
 <!--  <script defer src="https://threejs.org/examples/jsm/loaders/GLTFLoader.js"></script> -->
 <!-- <script src="https://threejs.org/build/three.js"></script> -->
 <!-- <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
<!-- 

<script type="importmap">
    {
    "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
        
    }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
</script> -->
  

<script>
document.body.style.overscrollBehaviorY = 'none';
document.body.style.overscrollBehaviorX = 'none';


 

let uiflag=true;
let stage1=false;
let stage2=false;
let stage3=false;
let stage4=false;
let stage5=false;
let addflag=false;
let mergeflag=false;
let bounceflag=false;
let forceAmount = 12;
var cubes=[];
window.큐브=cubes;
var pens=[];
let activeFloor = 0;
let orthoflag=false;
let sleepflag=true;

var stackHeight;
var 칸=4;
var bw=2
var bh=0.5
var tw=bw/칸
var th=bh/3
var ontouch=true;
var lastX;
var lastY;
var touchx;
var touchy;



function motion(name, n) {
    if(n==9){
        var n1=4
    }else{
        var n1=n
    }
    var unit = unitmotion[name];
    var temp = new Array();
    var temp1 = new Array();
    var n2=String(n1)

    if(n2.length==1||n2.length==2){
        var key = unit.meta.frameTags[n1 - 1];
        var item = unit.frames;
        for (var i = 0; i < (key.to - key.from)+1; i++) {
            var fr0 = item[String(n) + " " + String(i)];
            var fr = fr0["frame"];
            var x0 = fr["x"];
            var y0 = fr["y"];
            var w0 = fr["w"];
            var h0 = fr["h"];
            temp1.push([x0, y0, w0, h0])
        }
        return temp1;
    }else{
        unit.meta.frameTags.forEach(element => {
           if(element.name==n2){
            // console.log(element)
            var key = element;
            var item = unit.frames;
            for (var i = 0; i < (key.to - key.from)+1; i++) {
                var fr0 = item[n2+ " " + String(i)];
                var fr = fr0["frame"];
                var x0 = fr["x"];
                var y0 = fr["y"];
                var w0 = fr["w"];
                var h0 = fr["h"];
                temp1.push([x0, y0, w0, h0])
            }
            // console.log(temp1)
            

           }
        });
        return temp1;
    }
}



var ftiles=[];
class ftile{
    constructor (a, b, c, d, index,direction, flag, me,me2){
        this.body=me;
        this.body0=me2;
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.index=index;
        this.direction=direction;
        this.mx=-bw/2+(tw/2)+(tw)*(b);
        this.mz=-bw/2+(tw/2)+(tw)*(a);
        this.dx=-bw/2+(tw/2)+(tw)*(d);
        this.dz=-bw/2+(tw/2)+(tw)*(c);
        // this.time=time;
        // this.race=race;
        // this.num=num;
        // this.endtime;
        this.tic=0.15
        this.speed=Math.sqrt(5)
        this.start=elapsedTime;
        // if(this.mx==this.dx){

        //    if(this.mz>this.dz){
        //     this.speedo=new CANNON.Vec3(0,0,-this.tic)
        //     this.endtime=elapsedTime+(this.mz-this.dz)*5;
        //     this.큰거=this.mz;
        //     this.작거=this.dz;
        //    }else{
        //     this.speedo=new CANNON.Vec3(0,0,this.tic)
        //     this.endtime=elapsedTime+(this.dz-this.mz)*5;
        //     this.큰거=this.dz;
        //     this.작거=this.mz;
        //    }

        // }else{
        //     if(this.mx>this.dx){
        //       this.speedo=new CANNON.Vec3(-this.tic,0,0)
        //       this.endtime=elapsedTime+(this.mx-this.dx)*5;
        //       this.큰거=this.mx;
        //       this.작거=this.dx;
        //    }else{
        //       this.speedo=new CANNON.Vec3(this.tic,0,0)
        //       this.endtime=elapsedTime+(this.dx-this.mx)*5;
        //       this.큰거=this.dx;
        //       this.작거=this.mx;
        //    }
        // }
        
        
        this.dt=Math.sqrt(this.mx*this.mx+this.mz*this.mz+this.dx*this.dx+this.dz*this.dz-2*(this.mx*this.dx)-2*(this.mz*this.dz))*this.speed;
        this.vx=(this.dx-this.mx)/(this.dt*this.speed);
        this.vz=(this.dz-this.mz)/(this.dt*this.speed);
        
        console.log("x 변위: "+String(this.vx)+"  z 변위: "+String(this.vz))
        console.log(this)
        this.merge=flag;
        this.nx=a;
        this.ny=b;
        // console.log(this.body.boardpointer[this.a][this.b])
        if(flag){
          this.q=1;
        }else{
          this.q=0;
        }
        
        

        
        

    }
}

class Game2048 {
  constructor(size, index) {
    this.size = size;
    this.board = new Array(size).fill(null).map(() => new Array(size).fill(0));
    // this.spawnTile();
    this.spawnTile();
    this.boardChanged=false;
    this.index=index;
    this.boardpointer=[];
    for (let row = 0; row < this.size; row++) {
        var temp=[];
        for (let col = 0; col < this.size; col++) {
            temp.push([])
        }
        this.boardpointer.push(temp);
    }
    


    
    // this.move();
  }

  spawnTile(direction=5) {
    // if(direction=5){
    //   this.boardChanged=false;
    //   return ;

    // }
    let emptyPositions = [];
    if(direction==5){
      for (let row = 0; row < this.size; row++) {
        for (let col = 0; col < this.size; col++) {
          if (this.board[row][col] === 0&&(col==3||col==0||row==0||row==3)) {
            emptyPositions.push({ row: row, col: col });
          }
        }
      }
    }else{
      switch (direction) {
        case 'up':
          for (let row = this.size; row >= this.size; row--) {
            for (let col = 0; col < this.size; col++) {
              if (this.board[row][col] === 0&&(col==this.size||col==0||row==0||row==this.size)) {
                emptyPositions.push({ row: row, col: col });
              }
            }
          }
          break;
        case 'down':
          for (let row = 0; row < 1; row++) {
            for (let col = 0; col < this.size; col++) {
              if (this.board[row][col] === 0&&(col==this.size||col==0||row==0||row==this.size)) {
                emptyPositions.push({ row: row, col: col });
              }
            }
          }
          break;
        case 'left':
          for (let col = this.size; col >= this.size; col--) {
            for (let row = 0; row < this.size; row++) {
              if (this.board[row][col] === 0&&(col==this.size||col==0||row==0||row==this.size)) {
                emptyPositions.push({ row: row, col: col });
              }
            }
          }
          break;
        case 'right':
          for (let col = 0; col < 1; col++) {
            for (let row = 0; row < this.size; row++) {
              if (this.board[row][col] === 0&&(col==this.size||col==0||row==0||row==this.size)) {
                emptyPositions.push({ row: row, col: col });
              }
            }
          }
          break;
        default:
          return;
      }


    }
    

    if (emptyPositions.length > 0) {
      const position = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
      this.board[position.row][position.col] = Math.random() < 0.9 ? 2 : 4;

      createTile(th*0.7, tw, this.board[position.row][position.col], (tile) => {
        tile.position.set(
          0 - bw/2 + tw/2 + position.col * tw,
          0,
          0 - bw/2 + tw/2 + position.row * tw
        );
        createTextMesh(this.board[position.row][position.col].toString(), bw / 8, (textMesh) => {
          textMesh.position.y = (th/6)
          textMesh.position.z;
          textMesh.rotation.order = 'YXZ';
          textMesh.rotation.x = -Math.PI / 2;
          tile.userData["text"]=this.board[position.row][position.col].toString()
          tile.add(textMesh);
          cubes[this.index].mesh.add(tile);
          this.boardpointer[position.row][position.col]=tile;
        });
        
        
      });

      atchanged=elapsedTime;
    }
    this.boardChanged=false;
  }

  // Implement game logic for moving tiles and updating board state
  // ...
  move(row, col, newRow, newCol, direction) {
    if (this.board[newRow][newCol] === 0) {
      console.log(this.boardpointer[col][row]);
      this.board[newRow][newCol] = this.board[row][col];
      this.board[row][col] = 0;
      ftiles.push(new ftile(row, col, newRow, newCol, this.index, direction, false,this,this.boardpointer[row][col]))
      // renderer.setAnimationLoop(animation);
      this.boardChanged = true;

    }else if(this.board[newRow][newCol] === this.board[row][col]){
      
      console.log(this.boardpointer[col][row]);
      this.board[newRow][newCol] += this.board[row][col];
      this.board[row][col] = 0;
      ftiles.push(new ftile(row, col, newRow, newCol, this.index, direction, true,this,this.boardpointer[row][col]))
      this.boardChanged = true;

      if(stage4){
        if(this.board[newRow][newCol]==64){
          if(cubes.length-1==this.index){
            const game2048 = new Game2048(칸, cubes.length);
            // const box = createBox(0, boxSize / 2 + i * boxSize, 0, boxSize, boxSize/2, boxSize, game2048);
            // box.mesh.userData.body = box.body;
            // box.mesh.userData.game2048 = game2048;
            cubes.push(createBox(0,  (cubes.length) * bh+bh/2, 0, bw, bh, bw, game2048));
            cubes[cubes.length-1].mesh.userData.body = cubes[cubes.length-1].body;
            cubes[cubes.length-1].mesh.userData.game2048 = game2048
            // stackHeight++
            activeFloor=cubes.length-1;
          }else{
            cubes[this.index+1].mesh.userData.game2048.spawnTile();
          }
        }
      }
      
      
      if((stage1||stage3||stage4)||stage2){
        let force = new CANNON.Vec3();
        // var offset = new CANNON.Vec3(-bw/2+(tw/2)+(tw)*(col), 0, -bw/2+(tw/2)+(tw)*(row));
        switch (direction) {
          case 'up':
            force.set(0, 0, -forceAmount*Math.sqrt(this.board[newRow][newCol])*5);
            break;
          case 'down':
            force.set(0, 0, forceAmount*Math.sqrt(this.board[newRow][newCol])*5);
            break;
          case 'left':
            force.set(-forceAmount*Math.sqrt(this.board[newRow][newCol])*5, 0, 0);
            break;
          case 'right':
            force.set(forceAmount*Math.sqrt(this.board[newRow][newCol])*5, 0, 0);
            break;
          default:
            return;
        }
        var a=cubes[activeFloor].body.position
        // cubes[activeFloor].body.applyForce(force, cubes[activeFloor].body.position.clone().vadd(offset));
        cubes[activeFloor].body.applyForce(force, cubes[activeFloor].body.position);

      }
      
    }
  }

  moveBoard(direction){
    let rowStep, colStep, startRow, startCol;
    if (direction === "down" || direction === "right") {
      rowStep = 1;
      colStep = 1;
      startRow = 0;
      startCol = 0;
    } else {
      rowStep = -1;
      colStep = -1;
      startRow = this.size - 1;
      startCol = this.size - 1;
    }

    const rowCondition = direction === "down" || direction === "up";
    var temp=[];
    for (let row = startRow; row >= 0 && row < this.size; row += rowStep) {
      for (let col = startCol; col >= 0 && col < this.size; col += colStep) {
        if (this.board[row][col] === 0) continue;
        let newRow = row;
        let newCol = col;

        while (true) {
          const nextRow = newRow + (rowCondition ? rowStep : 0);
          const nextCol = newCol + (rowCondition ? 0 : colStep);

          if (nextRow < 0 || nextRow >= this.size || nextCol < 0 || nextCol >= this.size) break;

          if (this.board[nextRow][nextCol] === 0 || this.board[nextRow][nextCol] === this.board[row][col]) {
            newRow = nextRow;
            newCol = nextCol;
          } else {
            break;
          }
        }

        if (newRow !== row || newCol !== col) {
          temp.push([row, col, newRow, newCol, direction]);
          
        }
      }
    }

    temp.forEach((item)=>{
      this.move(item[0], item[1], item[2], item[3], item[4]);
    })

    if (this.boardChanged) {
      // renderer.setAnimationLoop(animation);
      // this.spawnTile(direction);
    }
  }
}

let aniflag=false;
let atchanged=0;


let elapsedTime = 0;
const clock = new THREE.Clock();




function createTextTexture(text, fontSize = 16, textColor = 'white', backgroundColor = 'rgba(0, 0, 0, 0.5)') {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  const padding = 10;
  ctx.font = `${fontSize}px Arial`;
  const textWidth = ctx.measureText(text).width;
  const textHeight = fontSize;

  canvas.width = textWidth + padding * 2;
  canvas.height = textHeight + padding * 2;

  ctx.fillStyle = backgroundColor;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.font = `${fontSize}px Arial`;
  ctx.fillStyle = textColor;
  ctx.fillText(text, padding, padding + textHeight * 0.8);

  const texture = new THREE.CanvasTexture(canvas);
  return texture;
}


function type(){
  for(var i=0;i<칸;i++){
    var temp=cubes[cubes.length-1].mesh.userData.game2048.board[i];
    console.log(String(temp[0])+" "+String(temp[1])+" "+String(temp[2])+" "+String(temp[3]));

  }
  
}


var gameoverflag=false;
const text = "W:위층, S:아래층, 방향키:타일 이동";
const fontSize = 24;

const texture = createTextTexture(text, fontSize);
const material = new THREE.SpriteMaterial({ map: texture, transparent: true });

const sprite = new THREE.Sprite(material);
sprite.scale.set(texture.image.width / 100, texture.image.height / 100, 1);

sprite.position.set(-window.innerWidth / 200 + texture.image.width / 200, window.innerHeight / 200 - texture.image.height / 200, -1);

const uiScene = new THREE.Scene();
uiScene.add(sprite);

// Add this line to your existing main scene rendering code
const uiCamera = new THREE.OrthographicCamera(-window.innerWidth / 200, window.innerWidth / 200, window.innerHeight / 200, -window.innerHeight / 200, 0.1, 1000);
uiCamera.position.set(0, 0, 1);


const button1 = new THREE.Sprite(new THREE.SpriteMaterial({ map: createTextTexture('Game1'), transparent: true }));
button1.scale.set(2, 1, 1);
button1.position.set(-1, 0, 0);
button1.name = 'Game1';

const button2 = new THREE.Sprite(new THREE.SpriteMaterial({ map: createTextTexture('Game2'), transparent: true }));
button2.scale.set(2, 1, 1);
button2.position.set(-1, -2, 0);
button2.name = 'Game2';

const button3 = new THREE.Sprite(new THREE.SpriteMaterial({ map: createTextTexture('Game3'), transparent: true }));
button3.scale.set(2, 1, 1);
button3.position.set(-1, -4, 0);
button3.name = 'Game3';

const button4 = new THREE.Sprite(new THREE.SpriteMaterial({ map: createTextTexture('Game4'), transparent: true }));
button4.scale.set(2, 1, 1);
button4.position.set(-1, -6, 0);
button4.name = 'Game4';

const button5 = new THREE.Sprite(new THREE.SpriteMaterial({ map: createTextTexture('Game5'), transparent: true }));
button5.scale.set(2, 1, 1);
button5.position.set(-1, 2, 0);
button5.name = 'Game5';

const uiScene0 = new THREE.Scene();
uiScene0.add(button1);
uiScene0.add(button2);
uiScene0.add(button3);
uiScene0.add(button4);
uiScene0.add(button5);
uiScene0.background = new THREE.Color(0x2e508d);

const uicamera0 = new THREE.OrthographicCamera(-5, 5, 5, -5, 0.1, 100);
uicamera0.position.set(0, -2, 10);


const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function handleTouchStart(event) {
  // event.preventDefault();
  lastX = (event.touches[0].clientX / window.innerWidth)*2 - 1;
  lastY = -(event.touches[0].clientY / window.innerHeight)*2+ 1;
  mouse.x=lastX;
  mouse.y=lastY;
  if(uiflag){
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    console.log(String(parseInt(mouse.x))+" "+String(parseInt(mouse.y)))
    raycaster.setFromCamera(mouse, uicamera0);
    const intersects = raycaster.intersectObjects(uiScene0.children);

    if (intersects.length > 0) {
      const firstIntersect = intersects[0];
      const clickedObjectName = firstIntersect.object.name;

      if (clickedObjectName === 'Game1') {
        console.log('Start Game button clicked');
        setting(7);
        uiflag=false;
        stage1=true;
      } else if (clickedObjectName === 'Game2') {
        console.log('Settings button clicked');
        setting1(1);
        uiflag=false;
        stage1=true;
        stage2=true;
      }else if (clickedObjectName === 'Game3') {
        console.log('Settings button clicked');
        

        uiflag=false;
        stage1=true;
        stage3=true;
        forceAmount=20;
        bw=3
        bh=0.5
        tw=bw/칸
        th=bh/3
        setting(9);
        
      }else if (clickedObjectName === 'Game4') {
        console.log('Settings button clicked');
        setting(1);
        uiflag=false;
        stage1=true;
        stage4=true;
      }else if (clickedObjectName === 'Game5') {
        console.log('game5');
        setting(5);
        uiflag=false;
        stage5=true;
        stage1=true;
        stackHeight=1;
      }
    }
  }
  
  
  
  ontouch=true
}

function handleTouchMove(event) {
  // event.preventDefault();
    touchx = (event.touches[0].clientX / window.innerWidth)*2 - 1;
    touchy = -(event.touches[0].clientY / window.innerHeight)*2+ 1;
    console.log("x: "+String(touchx)+"   y: "+String(touchy))
    // ctx.beginPath();
    // ctx.moveTo(touchx, touchy);
    // ctx.lineTo(grabx, graby);
    // ctx.stroke();
    if(ontouch){
      if(getdist(lastX, lastY, touchx, touchy)>0.3){
        

          if(lastX<-0.5){
              if(touchy-lastY>0.2){
                activeFloor++;
                if(activeFloor>cubes.length){
                  activeFloor=cubes.length;
                }
                ontouch=false;
            }else if(-touchy+lastY>0.2){
                activeFloor--;
                if(activeFloor<0){
                  activeFloor=0;
                }
                ontouch=false;
            }else if(touchx-lastX>0.2){
                restart();
                ontouch=false;
            }
          }else if(!cubes[activeFloor].mesh.userData.game2048.boardChanged&&!aniflag){
		  
            if(touchx-lastX>0.2){
                const game2048 = cubes[activeFloor].mesh.userData.game2048;
                game2048.moveBoard("right");
                ontouch=false;
            }else if(-touchx+lastX>0.2){
                const game2048 = cubes[activeFloor].mesh.userData.game2048;
                game2048.moveBoard("left");
                ontouch=false;
            }else if(touchy-lastY>0.2){
                const game2048 = cubes[activeFloor].mesh.userData.game2048;
                game2048.moveBoard("up");
                ontouch=false;
            }else if(-touchy+lastY>0.2){
                const game2048 = cubes[activeFloor].mesh.userData.game2048;
                game2048.moveBoard("down");
                ontouch=false;
            }
          }

          

          
          // console.log(game2048.)
       
      }
    }
    
    
    // lastX=pointx
    // lastY=pointy
  
}

function handleTouchEnd(event) {
  event.preventDefault();
  ontouch=false;
    // if(grabflag){
    //   grabx=pointx
    //   graby=pointy
    //   pointx=grabx;
    //   pointy=graby;
    //   ontouch=false;
    // }else{
    //   if(getdist(touchx, touchy, grabx, graby)<5){
    //     touchendx=lastX;
    //     touchendy=lastY;
    //     pointx=lastX;
    //     pointy=lastY;
    //     ontouch=false;
        
    //   }else{
    //     touchendx=lastX;
    //     touchendy=lastY;
    //     pointx=lastX;
    //     pointy=lastY;
    //     ontouch=false;
    //   }
    // }
    

}


function onClick(event) {
  event.preventDefault();
  if(uiflag){
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    console.log(String(parseInt(mouse.x))+" "+String(parseInt(mouse.y)))
    raycaster.setFromCamera(mouse, uicamera0);
    const intersects = raycaster.intersectObjects(uiScene0.children);

    if (intersects.length > 0) {
      const firstIntersect = intersects[0];
      const clickedObjectName = firstIntersect.object.name;

      if (clickedObjectName === 'Game1') {
        console.log('Start Game button clicked');
        setting(7);
        uiflag=false;
        stage1=true;
      } else if (clickedObjectName === 'Game2') {
        console.log('Settings button clicked');
        setting1(1);
        uiflag=false;
        stage1=true;
        stage2=true;
      }else if (clickedObjectName === 'Game3') {
        console.log('Settings button clicked');
        

        uiflag=false;
        stage1=true;
        stage3=true;
        forceAmount=20;
        bw=3
        bh=0.5
        tw=bw/칸
        th=bh/3
        setting(9);
        
      }else if (clickedObjectName === 'Game4') {
        console.log('Settings button clicked');
        setting(1);
        uiflag=false;
        stage1=true;
        stage4=true;
      }else if (clickedObjectName === 'Game5') {
        console.log('game5');
        setting(5);
        uiflag=false;
        stage5=true;
        stage1=true;
        stackHeight=1;
      }
    }
  }else{
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    // console.log(String(parseInt(mouse.x))+" "+String(parseInt(mouse.y)))
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children);

    if (intersects.length > 0) {

      const firstIntersect = intersects[0];
      const clickedObjectName = firstIntersect.object.name;
      // console.log(clickedObjectName);
      console.log(firstIntersect);
      let force2 = new CANNON.Vec3();

      force2.set(10000*(firstIntersect.point.x-camera.position.x), 10000*(firstIntersect.point.y-camera.position.y), 10000*(firstIntersect.point.z-camera.position.z));
      firstIntersect.object.userData["body"].applyForce(force2, firstIntersect.object.userData["body"].position);
 
    }
  }
  
}

window.addEventListener('click', onClick, false);

window.addEventListener("touchstart", handleTouchStart, false);
window.addEventListener("touchmove", handleTouchMove, false);
window.addEventListener("touchend", handleTouchEnd, false);


let boxSize = 1;
let boxh=boxSize/2;
// Set up the scene, camera, and renderer
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x2e508d);



if(orthoflag){
    const camera = new THREE.OrthographicCamera(-3, 3, 3, -3, 0.1, 1000);
    camera.position.set(0, 0, 0);
    camera.lookAt(0, 0, 0);
}
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const isoAngle = Math.atan(1 / Math.sqrt(2));
    camera.rotation.order = 'YXZ';

    camera.position.z = 5;
    camera.rotation.x = -isoAngle;



// const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

// camera.position.z = 5;
// // camera.position.y = 5;








const cameraTarget = new THREE.Object3D();

const frontalViewCamera = new THREE.OrthographicCamera(-3, 3, 3, -3, 0.1, 1000);
frontalViewCamera.position.set(0, 2, 4);
frontalViewCamera.lookAt(0, 2, 0);

const sideViewCamera = new THREE.OrthographicCamera(-3, 3, 3, -3, 0.1, 1000);
sideViewCamera.position.set(4, 2, 0);
sideViewCamera.lookAt(0, 2, 0);

const ambientLight= new THREE.AmbientLight(0xffffff,0.1);
scene.add(ambientLight);

const dL=new THREE.DirectionalLight(0xff00ff,0.1);
dL.position.set(10,20,5);
scene.add(dL);



const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Set up the physics world
const world = new CANNON.World();
// world.gravity.set(-0.06, -8, 0.1285);

// const groundShape = new CANNON.Plane();
// const groundBody = new CANNON.Body({ mass: 0 });
// groundBody.addShape(groundShape);
// groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);




let groundgeometry = new THREE.BoxGeometry(100, 2, 100);
let groundcolor =new THREE.Color('hsl('+String(30+6*(10))+', 100%, 50%)');
// const material = new THREE.MeshBasicMaterial({ color: 0x00ff00*Math.random() });

let groundmaterial = new THREE.MeshLambertMaterial({groundcolor});
let groundmesh = new THREE.Mesh(groundgeometry, groundmaterial);
groundmesh.position.set(0, -1, 0);
// scene.add(groundmesh);
let groundshape = new CANNON.Box(new CANNON.Vec3(100/2, 2/2 , 100/2));

let customMaterial = new CANNON.Material('customMaterial');
customMaterial.friction = 1; // Friction coefficient, range: 0-1
customMaterial.restitution = 0; // Restitution (elasticity), range: 0-1

let groundBody = new CANNON.Body({ mass: 0, shape: groundshape, material: customMaterial
});
groundBody.position.set(0, -1, 0);
// groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -0.02);
world.addBody(groundBody);








    // groundBody.position.y=boxh/2
world.gravity.set(0,-6,0);
world.broadphase = new CANNON.NaiveBroadphase();
world.solver.iterations = 80;



// Add a ground plane to the physics world

// const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
// // groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), 0);
// world.addBody(groundBody);

// groundBody.position.y=boxh/2



// const groundShape = new CANNON.Plane();
// const groundBody = new CANNON.Body({ mass: 0 });
// // groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 0), 0);
// groundBody.addShape(groundShape);
// world.addBody(groundBody);
// groundBody.position.y=0
 // groundBody.position.y=0

// const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
// groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
// world.addBody(groundBody);
// groundBody.position.y=boxh/2
// const cube = createBox(0, 1, 0, 1, 0.5, 1);
// cube.mesh.userData.body = cube.body;

// Define force constants


document.addEventListener('keydown', (event) => {
if (event.code === 'KeyW') {
activeFloor++;
if(activeFloor>cubes.length){
  activeFloor=cubes.length;
}
} else if (event.code === 'KeyS') {
activeFloor--;
if(activeFloor<0){
  activeFloor=0;
}
}else if (event.code === 'KeyR') {
   restart();
}

// activeFloor = Math.min(stackHeight, Math.max(0, activeFloor));
});

// Add event listener for arrow key presses
document.addEventListener('keydown', (event) => {
  if(aniflag||bounceflag) return;
  let force = new CANNON.Vec3();
  let direction;
  switch (event.code) {
    case 'ArrowUp':
      force.set(0, 0, -forceAmount);
      direction = 'up';
      break;
    case 'ArrowDown':
      force.set(0, 0, forceAmount);
      direction = 'down';
      break;
    case 'ArrowLeft':
      force.set(-forceAmount, 0, 0);
      direction = 'left';
      break;
    case 'ArrowRight':
      force.set(forceAmount, 0, 0);
      direction = 'right';
      break;
    default:
      return;
  }

  // if (activeFloor < stackHeight) {
  //   const floor = scene.children.find(
  //     (object) => object.userData.body && object.userData.game2048 && object.position.y === boxSize / 2 + activeFloor * boxSize
  //   );

  //   if (floor) {
  //     const game2048 = floor.userData.game2048;
  //     const boardChanged = game2048.moveBoard(direction);

  //     if (boardChanged) {
  //       // Update the tiles' appearance on the floor according to the updated game2048 board state
  //     }
  //   }
  // } else {
    

  // }
  // cube.body.applyForce(force, cube.body.position);
      // for(item of cubes){
      //   item.body.applyForce(force, item.body.position);
      // } 
      if(activeFloor==cubes.length){
        // fcubes.forEach((item)=>{
        //   item.body.applyForce(force, item.body.position);

        // })
      }else{
        for(var i=0;i<cubes.length;i++){
          if(i==activeFloor){
            if(!cubes[i].mesh.userData.game2048.boardChanged&&!aniflag){
              const game2048 = cubes[i].mesh.userData.game2048;
              game2048.moveBoard(direction);
              // console.log(game2048.)
            }
            // cubes[i].body.applyForce(force, cubes[i].body.position);

          }
        }
      }
        
  });

// for(item of cubes){
//     item.body.applyForce(force, item.body.position);
//   } 

// Create a function to add a new box to the stack


function restart(){


  scene.children.forEach((object) => {
      scene.remove(object);
      object.geometry.dispose();
      if (object.material.dispose) {
        object.material.dispose();
      } else if (object.material.length) { // For multi-materials
        object.material.forEach((material) => material.dispose());
      }

      if (object.material.map) {
        object.material.map.dispose();
      } else if (object.material.length) { // For multi-materials
        object.material.forEach((material) => {
          if (material.map) {
            material.map.dispose();
          }
        });
      }
      


    })
  

  
  cubes.forEach((object)=>{ 
    // object.geometry.dispose();
    // if (object.material.dispose) {
    //   object.material.dispose();
    // } else if (object.material.length) { // For multi-materials
    //   object.material.forEach((material) => material.dispose());
    // }

    // if (object.material.map) {
    //   object.material.map.dispose();
    // } else if (object.material.length) { // For multi-materials
    //   object.material.forEach((material) => {
    //     if (material.map) {
    //       material.map.dispose();
    //     }
    //   });
    // }
    world.remove(object.body)
    scene.remove(object);
  })

  
    scene.children.length=0;
    cubes.length=0;
 
 setting(stackHeight);

  // for (let i = 0; i < stackHeight; i++) {
  //   const game2048 = new Game2048(4, i);
  //   // const box = createBox(0, boxSize / 2 + i * boxSize, 0, boxSize, boxSize/2, boxSize, game2048);
  //   // box.mesh.userData.body = box.body;
  //   // box.mesh.userData.game2048 = game2048;
  //   cubes.push(createBox(0,  (i+1) * boxSize, 0, boxSize*2, boxSize, boxSize, game2048));
  //   cubes[cubes.length-1].mesh.userData.body = cubes[cubes.length-1].body;
  //   cubes[cubes.length-1].mesh.userData.game2048 = game2048
  // }
  // for (let i = 0; i < stackHeight; i++) {
  //   cubes[i].mesh.userData.body = cubes[i].body;
  // }
  activeFloor=cubes.length-1;
  gameoverflag=false;
  animate()

  

}

function createTextMesh(text, fontSize = 1, callback) {
  const fontLoader = new THREE.FontLoader();
  fontLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/fonts/helvetiker_regular.typeface.json', (font) => {
    const geometry = new THREE.TextGeometry(text, {
      font: font,
      size: 0.2,
      height:th/4 ,
    });
    geometry.computeBoundingBox();
    geometry.translate(-geometry.boundingBox.max.x / 2, -geometry.boundingBox.min.y-0.13, 0);
    const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const mesh = new THREE.Mesh(geometry, material);

    if (callback) {
      callback(mesh);
    }
  });
}



function createBox(x, y, z, width, height, depth, game2048) {  
  const geometry = new THREE.BoxGeometry(width, height, depth);
  // const color =new THREE.Color('hsl('+String(30+6*(y/boxh))+', 100%, 50%)');
  // const material = new THREE.MeshLambertMaterial({color});
  const material = new THREE.MeshBasicMaterial({ color: 0x00ff00*Math.random() });
  
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(0, y, 0);
  scene.add(mesh);
  const shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));

  const customMaterial = new CANNON.Material('customMaterial');
  customMaterial.friction = 0.2; // Friction coefficient, range: 0-1
  if(stage3){

  }
  customMaterial.restitution = 0.2; // Restitution (elasticity), range: 0-1
  if(stage3){
    customMaterial.friction = 0.8
  }

  const body = new CANNON.Body({ mass: 2, shape: shape, material: customMaterial, allowSleep: true,  sleepSpeedLimit: 100, 
  sleepTimeLimit: 0
 });
  body.position.set(0, y, 0);
  world.addBody(body);

  // const tgeometry = new THREE.BoxGeometry(bw*0.5, tw/4, bw*0.5);
  // const tmaterial = new THREE.MeshBasicMaterial({ color: getColorForNumber(0) });
  // const tile = new THREE.Mesh(geometry, material);
  // tile.position.set(0,1-bh/2+tw/2,0)
  // mesh.add(tile);

  for (let row = 0; row < 칸; row++) {
      for (let col = 0; col < 칸; col++) {
          createTile(th/2, tw, 0, (tile) => {
            tile.position.set(
              0 - bw/2 + tw/2 + col * tw,
              -th/2,
              0 - bw/2 + tw/2 + row * tw,
            );
            mesh.add(tile);
        });
        
        
    }
  }


  // createTile(th/4, bw, 0, (tile) => {
  //   tile.position.set(
  //     0,
  //     0-th,
  //     0
  //   );
    
  //   mesh.add(tile);
    
  // });


  if (game2048) {
    const boardSize = game2048.size;
    const tileSize = width / boardSize;
    // for (let row = 0; row < 4; row++) {
    //   for (let col = 0; col < 4; col++) {
    //     if(game2048.board[row][col]!=0){
    //       createTile(height, tileSize, 0, (tile) => {
    //         tile.position.set(
    //           0 - width / 2 + tileSize / 2 + col * tileSize,
    //           0,
    //           0 - depth / 2 + tileSize / 2 + row * tileSize
    //         );
    //         mesh.add(tile);
    //         game2048.boardpointer[row][col]=tile;
    //       });
    //     }
        
    //   }
    // }
  }
  return { mesh: mesh, body: body };
}


function setting(n= 8){
  stackHeight =n;
  for (let i = 0; i < stackHeight; i++) {
    const game2048 = new Game2048(칸, i);
    cubes.push(createBox(0,  (i) * bh+bh/2, 0, bw, bh, bw, game2048));
    cubes[cubes.length-1].mesh.userData.body = cubes[cubes.length-1].body;
    cubes[cubes.length-1].mesh.userData.game2048 = game2048
    cubes[cubes.length-1].body.sleepState=1;


    var loc=[];
      for (let row = 0; row < 칸; row++) {
          var temp=[];
          for (let col = 0; col < 칸; col++) {
              temp.push([-bw/2+(tw/2)+(tw)*(col),0, -bw/2+(tw/2)+(tw)*(row)])
          }
          this.loc=[];
      }
    
  }

  activeFloor=cubes.length-1;
  if(stage3){
    let topCubeBottomSurfaceY = cubes[0].mesh.position.y - cubes[0].mesh.scale.y * cubes[0].mesh.geometry.parameters.height / 2;
    // console.log(topCubeBottomSurfaceY)
    // groundBody.position.y=topCubeBottomSurfaceY-cubes[0].mesh.scale.y

    const anchorPoint = new CANNON.Vec3(0, -topCubeBottomSurfaceY, 0); // Bottom of the box
    const constraint = new CANNON.PointToPointConstraint(cubes[0].body, anchorPoint, groundBody, new CANNON.Vec3(0, 0, 0));
  }
  // let topCubeBottomSurfaceY = cubes[0].mesh.position.y - cubes[0].mesh.scale.y * cubes[0].mesh.geometry.parameters.height / 2;
  // const anchorPoint = new CANNON.Vec3(0, -topCubeBottomSurfaceY, 0); // Bottom of the box
  // const constraint = new CANNON.PointToPointConstraint(cubes[0].body, anchorPoint, groundBody, new CANNON.Vec3(0, topCubeBottomSurfaceY, 0));

  

}


function addbox(){
  for (let i = 0; i < 10; i++) {
      const boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
      const boxBody = new CANNON.Body({ mass: 10 });
      boxBody.addShape(boxShape);
      boxBody.position.set(0, 2, 0);
      world.addBody(boxBody);

      const boxGeometry = new THREE.BoxGeometry();
      const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
      boxMesh.userData.body=boxBody
      scene.add(boxMesh);
      
      cubes.push({mesh: boxMesh,body: boxBody})

  }

}
function setting1(n= 1){
  if(true){
    stackHeight =1;
    for (let i = 0; i < stackHeight; i++) {
      const game2048 = new Game2048(칸, i);
      cubes.push(createBox(0,  (i+1) * 3*boxSize+boxh/2, 0, 2*boxSize, 6*boxSize, 2*boxSize, game2048));
      cubes[cubes.length-1].mesh.userData.body = cubes[cubes.length-1].body;
      cubes[cubes.length-1].mesh.userData.game2048 = game2048
    }
    activeFloor=cubes.length-1;


    let topCubeBottomSurfaceY = cubes[0].mesh.position.y - cubes[0].mesh.scale.y * cubes[0].mesh.geometry.parameters.height / 2;
    // console.log(topCubeBottomSurfaceY)
    // groundBody.position.y=topCubeBottomSurfaceY-cubes[0].mesh.scale.y

    const anchorPoint = new CANNON.Vec3(0, -topCubeBottomSurfaceY, 0); // Bottom of the box
    const constraint = new CANNON.PointToPointConstraint(cubes[0].body, anchorPoint, groundBody, new CANNON.Vec3(0, topCubeBottomSurfaceY, 0));

    // const anchorPoint2 = new CANNON.Vec3(0.25, topCubeBottomSurfaceY, 0); // Bottom of the box
    // const constrain2 = new CANNON.PointToPointConstraint(cubes[0].body, anchorPoint, groundBody, new CANNON.Vec3(0.25, boxh/2, 0));
      // world.addConstraint(constraint);
      // world.addConstraint(constraint2);
  }
  

}

// Generate the initial stack of boxes



function createTile(height, size,  number = 0, callback){
  var material = new THREE.MeshBasicMaterial({ color: getColorForNumber(number) });
  var geometry = new THREE.BoxGeometry(size*0.9, height, size*0.9);
  if(number==0){
      material = new THREE.MeshBasicMaterial({ color:new THREE.Color('hsl('+String(70+4*(2))+', 70%, 60%)')});
      geometry = new THREE.BoxGeometry(size*0.9, height, size*0.9);
  }
  // const material = new THREE.MeshBasicMaterial({ color: getColorForNumber(number) });
  const tile = new THREE.Mesh(geometry, material);
   if (number !== 0) {
    createTextMesh(number.toString(), bw/8, (textMesh) => {
      textMesh.position.y = -th/16
      textMesh.position.z-=10
      textMesh.rotation.order = 'YXZ';
      textMesh.rotation.z = -Math.PI / 2;
      tile.userData["text"]=number.toString();
      tile.userData["time"]=elapsedTime ;
      tile.userData["text0"]=0 ;
      if (callback) {
        callback(tile);
      }
    });
  } else {
    if (callback) {
      callback(tile);
    }
  }
}

function getColorForNumber(number) {
  // Define colors for specific numbers. You can customize these colors as needed.
  const colors = {
    0: 0xCCCCCC,
    2: 0xEEEEEE,
    4: 0xEDD0A1,
    8: 0xF2B179,
    16: 0xF59563,
    32: 0xF67C5F,
    64: 0xF65E3B,
    128: 0xEDCF72,
    256: 0xEDCC61,
    512: 0xEDC850,
    1024: 0xEDC53F,
    2048: 0xEDC22E,
  };
  return colors[number] || 0x000000;
}


function animate2() {
  requestAnimationFrame(animate2);
  // renderer.render(uiScene0, uicamera0);
  renderer.clearDepth(); 
  console.log(0)
}



animate();

// Animate the scene
function animate() {
  scene.background = new THREE.Color(0x2e508d);
  if(uiflag){
    requestAnimationFrame(animate);
    renderer.render(uiScene0, uicamera0);
    return;
  }else if(gameoverflag){
    return;

  }else if(!stage1){
    return;
  }
  requestAnimationFrame(animate);

  elapsedTime += clock.getDelta();
  cubes.forEach((item)=>{ 
      // var matrix=item.mesh.userData["game2048"].board;
    let force0 = new CANNON.Vec3();
    force0.set(-0.04, 0, -0.36);    
    item.body.applyForce(force0, item.body.position);
  })
            

  if(ftiles.length!=0){
    aniflag=true;
    ftiles.sort(function(a, b) {
      return a.q - b.q;
    });
    ftiles.sort(function(a, b) {
      return a.elapsedTime - b.elapsedTime;
    });

  
  // let speed= 0.15*(Math.abs((item.c-item.a)+(item.d-item.b))/8);
  let speed= 0.15;

  // const vspeed=speed*2;
  var rmvftile=[];
  ftiles.forEach((item, index)=>{
    if(item.body0==""){
        item.body0=item.body.boardpointer[item.a][item.b];
        // rmvftile.push(index);
        return;
    }

    if(!item.merge&&item.body0!=[]) item.body.boardpointer[item.c][item.d]=item.body0;
    switch (item.direction) {
      case 'up':
        // if(item.body0==){
        //     rmvftile.push(index);
        //     return;
        // }
        console.log(item);
        item.body0.position.z-=speed;
        console.log("up")
        console.log(String(item.a)+","+String(item.b)+" -> "+String(item.c)+","+String(item.d));
        
       
        // item.nx-=vspeed;
        // console.log(item.body0.position.z);
        // console.log(item.dz);
        // console.log("result: "+String(item.body0.position.z-item.dz));
        
        var 결과=item.body0.position.z-item.dz;
        console.log(결과)
        break;
      case 'down':
        // if(item.body0==[]){
        //     rmvftile.push(index);
        //     return;
        // }
        console.log(item);
        item.body0.position.z+=speed;
        console.log("down")
      console.log(String(item.a)+","+String(item.b)+" -> "+String(item.c)+","+String(item.d));

        
        
        // console.log(item.dz);
        // console.log("result: "+String(item.body0.position.z-item.dz));
        
        var 결과=item.dz-item.body0.position.z;
        console.log(결과)
        break;
      case 'left':
        // if(item.body0!=[]){
        //     rmvftile.push(index);
        //     return;
        // }
        console.log(item);
        item.body0.position.x-=speed;
        console.log("left")
      console.log(String(item.a)+","+String(item.b)+" -> "+String(item.c)+","+String(item.d));
        
        
        // console.log(item.dx);
        // console.log("result: "+String(item.body0.position.x-item.dx));
        var 결과=item.body0.position.x-item.dx;
        console.log(결과)
        break;
      case 'right':
        // if(item.body0==[]){
        //     rmvftile.push(index);
        //     return;
        // }
        console.log(item);
        item.body0.position.x+=speed;
        console.log("rigth")
      console.log(String(item.a)+","+String(item.b)+" -> "+String(item.c)+","+String(item.d));
        

        
        // console.log(item.body.position.x);
        // console.log(item.dx);
        // console.log("result: "+String(item.body0.position.x-item.dx));
        var 결과=item.dx-item.body0.position.x;
        console.log(결과)
        break;
      default:
        return;
    }

    // if((Math.abs(item.body0.position.x-item.dx)<=0.2&&Math.abs(item.body0.position.z-item.dz)<=0.2)||){
    if((결과<0.10)){
      atchanged=elapsedTime;
      console.log("??")
      item.body0.position.x=item.dx;
      item.body0.position.z=item.dz;

      if(item.merge){
        type();
        // console.log(ftiles)
        var num=parseInt(item.body.board[item.c][item.d])
        
        // item.body.boardpointer[item.c][item.d].userData["text"]=String(num*2);
        cubes[item.index].mesh.remove(item.body0);      
        item.body.boardpointer[item.a][item.b]=[];
        console.log(String(item.c)+", "+String(item.d))
        if(item.body.boardpointer[item.c][item.d]!=""){
          item.body.boardpointer[item.c][item.d].userData["time"]=elapsedTime;
          item.body.boardpointer[item.c][item.d].userData["merge"]=1;
          const color = getColorForNumber(num);
          var tile=item.body.boardpointer[item.c][item.d];
          if (tile.material.color.getHex() !== color) {
            tile.material.color.set(color);
          }

          const text = num.toString();
          if (tile.children.length === 0) {
            if (tile.children.length >0) {
              tile.remove(tile.children[0]);
            }
            if(num!=0){
              createTextMesh(num.toString(), bw / 8, (textMesh) => {
                textMesh.position.y = th/6
                textMesh.position.z;
                textMesh.rotation.order = 'YXZ';

                textMesh.rotation.x = -Math.PI / 2;
                tile.userData["text"]=text
                tile.add(textMesh);
              });
            }
          }else{
            if (tile.children.length >0) {
              tile.remove(tile.children[0]);
              if (tile.children.length >0) {
                tile.remove(tile.children[0]);
                
              }
            }
            if(num!=0){
              createTextMesh(num.toString(), bw / 8, (textMesh) => {
                textMesh.position.y = th/6
                textMesh.position.z;
                textMesh.rotation.order = 'YXZ';
                textMesh.rotation.x = -Math.PI / 2;
                tile.userData["text"]=text
                tile.add(textMesh);
              });
            }
              
          }
          atchanged=elapsedTime;
        }else{


        }
        
        type();
        

      }else{
        // cubes[item.index].mesh.userData.game2048.boardpointer[item.c][item.d].push(cubes[item.index].mesh.userData.game2048.boardpointer[item.a][item.b].pop());
        
        // item.body.boardpointer[item.a][item.b]=[];
        // item.body.boardpointer[item.c][item.d]=item.body.boardpointer[item.a][item.b];
        type();


        console.log(item.body.boardpointer[item.c][item.d])
        // console.log(item.body.boardpointer[item.a][item.b])


        
      }
      rmvftile.push(index);
    }
  })

  // rmvftile.sort(function(a, b) {
  //   return b - a;
  // });
  
  if(rmvftile.length!=0&&ftiles.length==rmvftile.length&&ftiles[0].body.boardChanged){
    ftiles[0].body.spawnTile(ftiles[0].body.direction);
    if(sleepflag){
      sleepflag=false;
    }
  }
  rmvftile.sort(function(a, b) {
    return b - a;
  });

  rmvftile.forEach((item)=>{ 
      ftiles.splice(item, 1);

  })
  }else{
    aniflag=false;
  }




  // }
  if(stage5){
    if(!addflag){
      addflag=true;
      // const loader = new OBJLoader();
      // loader.load(
      //   'https://raw.githubusercontent.com/Radetzki87/web1/master/pen5.obj',
      //   (object) => {
      //     // The object is loaded successfully
      //     // const geometry = new THREE.BoxGeometry(width, height, depth);
      //     // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00*Math.random() });
      //     const mesh = object.children[0]
      //     mesh.position.set(0, (cubes.length-1) * boxSize, 0);
      //     console.log(object.children[0])
      //     scene.add(mesh);

      //     const shape = new CANNON.Box(new CANNON.Vec3(width / 2, height/2 , depth / 2));
      //     const customMaterial = new CANNON.Material('customMaterial');
      //     customMaterial.friction = 0.4; // Friction coefficient, range: 0-1
      //     customMaterial.restitution = 0.4; // Restitution (elasticity), range: 0-1

      //     const body = new CANNON.Body({ mass: 2, shape: shape, material: customMaterial
      //    });
      //     body.position.set(0, (cubes.length-1) * boxSize, 0);
      //     world.addBody(body);
      //     mesh.userData.body = mesh.body;
      //     // scene.add(object);
      //   },
      //   (xhr) => {
      //     // Called while the OBJ file is being loaded
      //     console.log((xhr.loaded / xhr.total) * 100 + '% loaded');
      //   },
      //   (error) => {
      //     // Called if there's an error loading the OBJ file
      //     console.error('An error occurred:', error);
      //   }
      // );
      const geometry = new THREE.BoxGeometry(boxSize/4, boxSize/4, boxSize/4);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00*Math.random() });
      const mesh = new THREE.Mesh(geometry, material);

      mesh.position.set(0, (cubes.length-1) * boxSize, 0);
      scene.add(mesh);

      const shape = new CANNON.Box(new CANNON.Vec3(boxSize/4, boxSize/4 , boxSize/4));
      const customMaterial = new CANNON.Material('customMaterial');
      customMaterial.friction = 0.4; // Friction coefficient, range: 0-1
      customMaterial.restitution = 0.2; // Restitution (elasticity), range: 0-1

      const body = new CANNON.Body({ mass: 2, shape: shape, material: customMaterial
     });
      body.position.set(0, (cubes.length-1) * boxSize, 0);
      world.addBody(body);

      mesh.userData.body = body;
      pens.push({ mesh: mesh, body: body })
      forceAmount=1000;



    }else{

    }
  
}
    

  if(false){
    cubes.forEach((item)=>{
      var matrix=item.mesh.userData["game2048"].board;
      let force0 = new CANNON.Vec3();
      
      for(i=0;i<4;i++){
        for(j=0;j<4;j++){
          if(matrix[i][j]>0){
            var offset = new CANNON.Vec3(j*(boxSize/2)-(boxSize), 0, i*(boxSize/2)-(boxSize));
            force0.set(0, -1*matrix[i][j],0);
            item.body.applyForce(force0, item.body.position.clone().vadd(offset));
            // console.log(matrix[i][j])
          }
          
        }  
      }
    })
  }


  if(false){
    cubes.forEach((item)=>{
      // var matrix=item.mesh.userData["game2048"].board;
     
      let force0 = new CANNON.Vec3();
      if(Math.sqrt(Math.abs((item.body.position.x)*(item.body.position.z)))<0.2){
        force0.set(50*(0-item.body.position.x), 0, 50*(0-item.body.position.z)); 
        item.body.applyForce(force0, item.body.position);
      }else{
        force0.set(10*(0-item.body.position.x), 0, 10*(0-item.body.position.z)); 
        item.body.applyForce(force0, item.body.position);
      }
      

      
    })
  }

  if(elapsedTime-atchanged>0&&elapsedTime-atchanged<0.1){
    bounceflag=true;
    console.log(activeFloor);
    cubes[activeFloor].mesh.children.forEach((item)=>{
    // for(item of cubes[activeFloor].mesh.children){
        if(elapsedTime-item.userData.time>0&&elapsedTime-item.userData.time<0.1){
          item.scale.x = 0.6+4*(elapsedTime-item.userData.time);
          item.scale.z = 0.6+4*(elapsedTime-item.userData.time);
          item.scale.y =  0.5*Math.cos(2*2*15.708 * (elapsedTime-item.userData.time)) + 0.4
        }
    })
  }else{
    bounceflag=false;
  }

  if(orthoflag){
      if(activeFloor==cubes.length){
          camera.position.set(
          cubes[cubes.length-1].mesh.position.x+bh*2.5,
          cubes[cubes.length-1].mesh.position.y+bh*2,
          cubes[cubes.length-1].mesh.position.z+bh*5,
          
        );
        cubes.forEach((item)=>{
          item.mesh.material.opacity = 1
          item.mesh.material.transparent = false;
          item.mesh.children.forEach((tile) => {
            tile.material.opacity =  0;
            tile.material.transparent = true;
            tile.children.forEach((text) => {
              text.material.opacity = 1;
              text.material.transparent = true;
            })
          });
        })
    }else{
      for(var i=0;i<cubes.length;i++){
        if(i==activeFloor){
          camera.position.set(
          cubes[0].mesh.position.x+bh*2.5,
          cubes[cubes.length-1].mesh.position.y+boxSize*2+boxSize/4*(i),
          cubes[0].mesh.position.z+boxh*5,
        );
          cubes[i].mesh.material.opacity = 0.5;
          cubes[i].mesh.material.transparent = true;
          cubes[i].mesh.children.forEach((tile) => {
            tile.material.opacity =  1
            tile.material.transparent = false;
            tile.children.forEach((text) => {
              text.material.opacity = 1;
              text.material.transparent = false;

            })
          });
        }else{
          // cubes[i].mesh.material.opacity =  0.25-((i-activeFloor)/(cubes.length+1));
          cubes[i].mesh.material.opacity =  0.25-((i-activeFloor)/cubes.length);
          cubes[i].mesh.material.transparent = true;
          cubes[i].mesh.children.forEach((tile) => {

            tile.material.opacity = 0.2-((i-activeFloor)/cubes.length);
            // tile.material.opacity=0.0
            tile.material.transparent = true;
            tile.children.forEach((text) => {
              // text.material.opacity = 0.0
              text.material.opacity = 0.1-((i-activeFloor)/cubes.length);
              text.material.transparent = true;

            })
          });
        }
      }
    }
  }else{
    if(activeFloor==cubes.length){
          camera.position.set(
          0,
          (cubes.length+3)*bh,
          bw*3,
          
        );
        // camera.lookAt(0, 0, 0);
        cubes.forEach((item)=>{
          item.mesh.material.opacity = 1
          item.mesh.material.transparent = false;
          item.mesh.children.forEach((tile) => {
            tile.material.opacity =  0;
            tile.material.transparent = true;
          });
        })
    }else{
      for(i in cubes){
        if(i==activeFloor){
          camera.position.set(
          cubes[i].mesh.position.x,
          cubes[i].mesh.position.y+bw*1,
          cubes[i].mesh.position.z+bw*1.5,
        );
          cubes[i].mesh.material.opacity = 0.1;
          cubes[i].mesh.material.transparent = true;
          cubes[i].mesh.children.forEach((tile) => {
            tile.material.opacity =  1
            tile.material.transparent = false;
            tile.children.forEach((text) => {
              text.material.opacity = 1;
              text.material.transparent = false;

            })
          });
        }else{
          // cubes[i].mesh.material.opacity =  0.25-((i-activeFloor)/(cubes.length+1));
          cubes[i].mesh.material.opacity = 0.1-((i-activeFloor)/(cubes.length+1));
          cubes[i].mesh.material.transparent = true;
          cubes[i].mesh.userData.game2048.boardpointer.forEach((row)=>{
            row.forEach((tile0)=>{
              if(tile0!=""){
                tile0.material.opacity = 0.0
                tile0.material.transparent = true;
              }
              
               
            })
          })
          cubes[i].mesh.children.forEach((tile) => {
            // tile.material.opacity = 0.1-((i-activeFloor)/cubes.length);
            tile.material.opacity = 0.2-((i-activeFloor)/cubes.length);
            tile.material.transparent = true;
            tile.children.forEach((text) => {
              // text.material.opacity = 0.1-((i-activeFloor)/cubes.length);
              text.material.opacity = 0
              text.material.transparent = true;

            })
          });
        }
      }
    }
  }


    
  

  // const activeBox = scene.children.find(
  //   (object) => object.userData.body && object.userData.game2048 && Math.round((object.position.y - boxSize / 2) / boxSize) === activeFloor
  // );

  // if (activeBox) {
  //   // Calculate the position of the top-left tile on the activeBox
  //   const tileSize = boxSize / activeBox.userData.game2048.size;
  //   const topLeftTilePosition = new THREE.Vector3(
  //     activeBox.position.x - boxSize / 2 + tileSize / 2,
  //     activeBox.position.y + boxSize / 2 + tileSize / 2,
  //     activeBox.position.z - boxSize / 2 + tileSize / 2
  //   );

  //   // Update the camera position based on the top-left tile's position
  //   camera.position.set(
  //     topLeftTilePosition.x + boxSize * 2,
  //     topLeftTilePosition.y + boxSize * 2,
  //     topLeftTilePosition.z + boxSize * 2
  //   );

  //   // Update the camera target to the top-left tile's position
  //   cameraTarget.position.copy(topLeftTilePosition);
  //   camera.lookAt(cameraTarget.position);
  // }


  

  //  scene.children.forEach((object) => {
  //   if (object.userData.body && object.userData.game2048) {
  //     const floor = Math.round((object.position.y - boxSize / 2) / boxSize);
  //     const isActiveFloor = floor === activeFloor;

  //     // Update box material
  //     object.material.opacity = isActiveFloor ? 1 : 0.3;
  //     object.material.transparent = !isActiveFloor;

  //     // Update tile materials
  //     object.children.forEach((tile) => {
  //       tile.material.opacity = isActiveFloor ? 1 : 0.3;
  //       tile.material.transparent = !isActiveFloor;
  //     });
  //   }
  // });


// scene.children.forEach((object) => {
//   if (object.userData.body && object.userData.game2048) {
//     const game2048 = object.userData.game2048;
//     object.children.forEach((tile, index) => {
//       const row = Math.floor(index / game2048.size);
//       const col = index % game2048.size;
//       const number = game2048.board[row][col];
//       const color = getColorForNumber(number);

//       if (tile.material.color.getHex() !== color) {
//         tile.material.color.set(color);
//       }

//       if (number !== 0) {
//         const text = number.toString();

//         if (tile.children.length === 0 || tile.children[0].userData.text !== text) {
//           if (tile.children.length > 0) {
//             tile.remove(tile.children[0]);
//           }
//           if(number!=0){
//             createTextMesh(text, boxSize / 4, (textMesh) => {
//               textMesh.position.y = -boxSize / 16;
//               textMesh.userData.text = text;
//               textMesh.rotation.x = -Math.PI / 2;
//               tile.add(textMesh);
//             });
//           }
          
//         }
//       } else {
//         if (tile.children.length > 0) {
//           tile.remove(tile.children[0]);
//         }
//       }
//     });
//   }
// });


  // Update the physics world
  world.step(1 / 60);

  cubes.forEach((item)=>{
    item.mesh.position.copy(item.mesh.userData.body.position);
    item.mesh.quaternion.copy(item.mesh.userData.body.quaternion);
  })
  
  var overlimit=0;
  // Update the position and rotation of the meshes to match their physics bodies
  scene.children.forEach((object) => {
      if(object.position.y<1){
        overlimit++;
  }
  // if (object.userData.body) {
  //   object.position.copy(object.userData.body.position);
  //   object.quaternion.copy(object.userData.body.quaternion);
  // }
  

});

if(overlimit>cubes.length-3){
  // gameoverflag=true;
}

// Render the scene
renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
renderer.setScissorTest(true);
renderer.render(scene, camera);

renderer.autoClear = false;

var 점수=0;

for(var i=0;i<cubes.length;i++){
  cubes[i].mesh.userData.game2048.board.forEach((row) => {
      row.forEach((num) => {
        점수+=num;
        // console.log(text.userData["text"])
        // if(text.children.length!=0){
        //   console.log("1")
        //   console.log(text.children[0].userData["text"]);
        // }

      })
  });
  
}

if(!gameoverflag){
  const text = "W:위층, S:아래층, 방향키:타일 이동 POINT: "+ String(점수);
  const fontSize = 24;

  const texture = createTextTexture(text, fontSize);
  const material = new THREE.SpriteMaterial({ map: texture, transparent: true });

  const sprite = new THREE.Sprite(material);
  sprite.scale.set(texture.image.width / 100, texture.image.height / 100, 1);

  sprite.position.set(-window.innerWidth / 200 + texture.image.width / 200, window.innerHeight / 200 - texture.image.height / 200, -1);

  
  uiScene.remove(uiScene.children[uiScene.children.length-1]);
  uiScene.add(sprite);
}else{
  const text = "게임오버!! 다시시작: R  최종 POINT: "+ String(점수);
  const fontSize = 24;

  const texture = createTextTexture(text, fontSize);
  const material = new THREE.SpriteMaterial({ map: texture, transparent: true });

  const sprite = new THREE.Sprite(material);
  sprite.scale.set(texture.image.width / 50, texture.image.height / 50, 1);

  sprite.position.set(-window.innerWidth / 200 + texture.image.width / 100, window.innerHeight / 200 - texture.image.height / 100, -1);

  
  uiScene.remove(uiScene.children[uiScene.children.length-1]);
  uiScene.add(sprite);

}





renderer.clearDepth(); // clear the depth buffer
renderer.render(uiScene, uiCamera); // render the UI scene and camera


if(gameoverflag) return;

for(var i=0;i<cubes.length;i++){
  if(i==activeFloor){
    camera.position.set(
    +boxSize*2,
    cubes[i].mesh.position.y+boxSize*2,
    +boxSize*2,
  );
    cubes[i].mesh.material.opacity = 0.2;
    cubes[i].mesh.material.transparent = true;
    cubes[i].mesh.children.forEach((tile) => {
      tile.material.opacity =  1
      tile.material.transparent = false;
      tile.children.forEach((text) => {
        text.material.opacity = 1;
        text.material.transparent = false;

      })
    });
  }else{
    cubes[i].mesh.material.opacity = 1;
    // cubes[i].mesh.material.opacity =  0
    cubes[i].mesh.material.transparent = false;
    cubes[i].mesh.children.forEach((tile) => {

      tile.material.opacity = 1;
      tile.material.transparent = false;
      tile.children.forEach((text) => {
        text.material.opacity = false;
        text.material.transparent = false;

      })
    });
  }
}
scene.background = new THREE.Color(0x4e508d);
const width = window.innerWidth / 6;
const height = window.innerHeight / 4;
renderer.setViewport(0, 0, width, height);
renderer.setScissor(0, 0, width, height);
renderer.setScissorTest(true);
renderer.render(scene, frontalViewCamera);

  scene.background = new THREE.Color(0x4e501d);
  renderer.setViewport(window.innerWidth - width, 0, width, height);
  renderer.setScissor(window.innerWidth - width, 0, width, height);
  renderer.setScissorTest(true);
  renderer.render(scene, sideViewCamera);
}


// Start the animation loop
if(!gameoverflag) animate();

// Handle window resizing
window.addEventListener("resize", () => {
const width = window.innerWidth;
const height = window.innerHeight;

renderer.setSize(width, height);
camera.aspect = width / height;
camera.updateProjectionMatrix();
});



function getdist(x2, y2, x3, y3) {
    var dstx = Math.abs(x2 - x3);
    var dsty = Math.abs(y2 - y3);
    if (dstx > dsty) {
        return 1.4 * dsty + 1.0 * (dstx - dsty)
    } else {
        return 1.4 * dstx + 1.0 * (dsty - dstx)
    }
}
// Function to add a new box at a random position above the stack
function spawnNewBox() {
const randomX = Math.random() * 2 - 1;
const randomZ = Math.random() * 2 - 1;
const newBox = createBox(randomX, stackHeight * boxSize + boxSize / 2, randomZ, boxSize, boxSize, boxSize);
newBox.mesh.userData.body = newBox.body;
}

// Add event listener for user input to spawn a new box
document.addEventListener("keydown", (event) => {
if (event.code === "Space") {
// spawnNewBox();
}
});

	</script>
</body>
</html>
